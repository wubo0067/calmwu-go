// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

/*
 * @Author: calmwu
 * @Date: 2019-12-02 16:04:57
 * @Last Modified by: calmwu
 * @Last Modified time: 2019-12-02 16:30:21
 */

package main

import "sync"

// NOTE: this is how easy it is to define a generic type

// NumChannel channel的封装对象
type NumChannel struct {
	C          chan int
	mutex      sync.Mutex
	closedFlag bool
}

// NewNumChannel 创建函数
func NewNumChannel(size int) *NumChannel {
	customChannel := new(NumChannel)
	if size > 0 {
		customChannel.C = make(chan int, size)
	} else {
		customChannel.C = make(chan int)
	}
	customChannel.closedFlag = false
	return customChannel
}

// IsClosed 判断是否被关闭
func (cc *NumChannel) IsClosed() bool {
	cc.mutex.Lock()
	defer cc.mutex.Unlock()
	return cc.closedFlag
}

// SafeClose 安全的关闭channel
func (cc *NumChannel) SafeClose() {
	cc.mutex.Lock()
	defer cc.mutex.Unlock()
	if !cc.closedFlag {
		close(cc.C)
		cc.closedFlag = true
	}
}

// SafeSend 安全的发送数据
func (cc *NumChannel) SafeSend(value int, block bool) (ok, closed bool) {
	defer func() {
		if recover() != nil {
			closed = true
			ok = false
		}
	}()

	if block {
		cc.C <- value
	} else {
		select {
		case cc.C <- value:
			ok = true
		default:
			ok = false
		}
	}
	closed = false
	return
}

// Read 读取
func (cc *NumChannel) Read(block bool) (val int, ok bool) {
	if block {
		val, ok = <-cc.C
	} else {
		select {
		case val, ok = <-cc.C:
			if !ok && !cc.closedFlag {
				cc.mutex.Lock()
				defer cc.mutex.Unlock()
				cc.closedFlag = true
			}
		default:
			ok = false
		}
	}
	return
}
